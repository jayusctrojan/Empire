"""
Empire v7.3 - AI Studio Classification Service
Task 78: Implement Department Classification Management

This service handles viewing and correcting department classifications
of user content. Classifications are generated by AGENT-008 (Department Classifier)
and can be corrected by users to improve future classification accuracy.

Features:
- List classifications with filtering by department, confidence, correction status
- View classification details with reasoning and keywords
- Correct misclassified content
- Reprocess content with corrected classification
- Log feedback for model improvement
"""

from datetime import datetime, timezone
from typing import List, Optional, Dict, Any
from dataclasses import dataclass, field
import structlog

from app.services.supabase_storage import get_supabase_storage

logger = structlog.get_logger(__name__)


# ============================================================================
# Data Models
# ============================================================================

@dataclass
class Classification:
    """Represents a content classification"""
    id: str
    user_id: str
    document_id: Optional[str] = None
    content_hash: Optional[str] = None
    filename: Optional[str] = None
    content_preview: Optional[str] = None
    department: str = ""
    confidence: float = 0.0
    reasoning: Optional[str] = None
    keywords_matched: List[str] = field(default_factory=list)
    secondary_department: Optional[str] = None
    secondary_confidence: Optional[float] = None
    user_corrected_department: Optional[str] = None
    correction_reason: Optional[str] = None
    corrected_at: Optional[datetime] = None
    created_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "userId": self.user_id,
            "documentId": self.document_id,
            "contentHash": self.content_hash,
            "filename": self.filename,
            "contentPreview": self.content_preview,
            "department": self.department,
            "confidence": self.confidence,
            "reasoning": self.reasoning,
            "keywordsMatched": self.keywords_matched,
            "secondaryDepartment": self.secondary_department,
            "secondaryConfidence": self.secondary_confidence,
            "userCorrectedDepartment": self.user_corrected_department,
            "correctionReason": self.correction_reason,
            "correctedAt": self.corrected_at.isoformat() if self.corrected_at else None,
            "createdAt": self.created_at.isoformat() if self.created_at else None,
        }


@dataclass
class ClassificationFilters:
    """Filters for listing classifications"""
    department: Optional[str] = None
    confidence_min: Optional[float] = None
    corrected: Optional[bool] = None
    search_query: Optional[str] = None


# ============================================================================
# Exceptions
# ============================================================================

class ClassificationNotFoundError(Exception):
    """Raised when a classification is not found"""
    pass


class ClassificationUpdateError(Exception):
    """Raised when a classification update fails"""
    pass


# ============================================================================
# Classification Service
# ============================================================================

class ClassificationService:
    """Service for managing content classifications"""

    def __init__(self):
        self._supabase = None

    @property
    def supabase(self):
        """Lazy load Supabase client"""
        if self._supabase is None:
            self._supabase = get_supabase_storage()
        return self._supabase

    def _parse_datetime(self, value: Any) -> Optional[datetime]:
        """Parse datetime from string or return as-is if already datetime"""
        if value is None:
            return None
        if isinstance(value, datetime):
            return value
        if isinstance(value, str):
            try:
                if value.endswith('Z'):
                    value = value[:-1] + '+00:00'
                return datetime.fromisoformat(value)
            except ValueError:
                return None
        return None

    def _row_to_classification(self, row: Dict[str, Any]) -> Classification:
        """Convert a database row to a Classification object"""
        keywords = row.get("keywords_matched", [])
        if isinstance(keywords, str):
            import json
            try:
                keywords = json.loads(keywords)
            except (json.JSONDecodeError, TypeError, ValueError):
                keywords = []

        return Classification(
            id=row["id"],
            user_id=row["user_id"],
            document_id=row.get("document_id"),
            content_hash=row.get("content_hash"),
            filename=row.get("filename"),
            content_preview=row.get("content_preview"),
            department=row.get("department", ""),
            confidence=float(row.get("confidence", 0)),
            reasoning=row.get("reasoning"),
            keywords_matched=keywords if keywords else [],
            secondary_department=row.get("secondary_department"),
            secondary_confidence=float(row["secondary_confidence"]) if row.get("secondary_confidence") else None,
            user_corrected_department=row.get("user_corrected_department"),
            correction_reason=row.get("correction_reason"),
            corrected_at=self._parse_datetime(row.get("corrected_at")),
            created_at=self._parse_datetime(row.get("created_at")),
        )

    async def list_classifications(
        self,
        user_id: str,
        filters: Optional[ClassificationFilters] = None,
        skip: int = 0,
        limit: int = 50
    ) -> List[Classification]:
        """
        List classifications with optional filtering.

        Args:
            user_id: The user ID to filter by
            filters: Optional filters for department, confidence, corrected status
            skip: Number of records to skip (pagination)
            limit: Maximum number of records to return

        Returns:
            List of Classification objects
        """
        try:
            # Build query
            query = self.supabase.client.table("studio_classifications").select("*")

            # Always filter by user_id
            query = query.eq("user_id", user_id)

            # Apply filters
            if filters:
                if filters.department:
                    query = query.eq("department", filters.department)
                if filters.confidence_min is not None:
                    query = query.gte("confidence", filters.confidence_min)
                if filters.corrected is not None:
                    if filters.corrected:
                        query = query.not_.is_("user_corrected_department", "null")
                    else:
                        query = query.is_("user_corrected_department", "null")
                if filters.search_query:
                    search_term = f"%{filters.search_query}%"
                    query = query.or_(
                        f"filename.ilike.{search_term},"
                        f"content_preview.ilike.{search_term},"
                        f"reasoning.ilike.{search_term}"
                    )

            # Order by most recent first
            query = query.order("created_at", desc=True)

            # Apply pagination
            query = query.range(skip, skip + limit - 1)

            result = query.execute()

            if not result.data:
                return []

            return [self._row_to_classification(row) for row in result.data]

        except Exception as e:
            logger.error("Failed to list classifications", error=str(e), user_id=user_id)
            raise

    async def get_classification(self, classification_id: str, user_id: str) -> Classification:
        """
        Get classification details by ID.

        Args:
            classification_id: The classification ID
            user_id: The user ID (for authorization)

        Returns:
            Classification object

        Raises:
            ClassificationNotFoundError: If classification not found
        """
        try:
            result = self.supabase.client.table("studio_classifications") \
                .select("*") \
                .eq("id", classification_id) \
                .eq("user_id", user_id) \
                .execute()

            if not result.data:
                raise ClassificationNotFoundError(f"Classification {classification_id} not found")

            return self._row_to_classification(result.data[0])

        except ClassificationNotFoundError:
            raise
        except Exception as e:
            logger.error("Failed to get classification", error=str(e), classification_id=classification_id)
            raise

    async def correct_classification(
        self,
        classification_id: str,
        user_id: str,
        new_department: str,
        reason: Optional[str] = None
    ) -> Classification:
        """
        Correct a misclassified content.

        Args:
            classification_id: The classification ID
            user_id: The user ID
            new_department: The corrected department
            reason: Optional reason for the correction

        Returns:
            Updated Classification object
        """
        try:
            # Get current classification
            classification = await self.get_classification(classification_id, user_id)

            # Update classification
            update_data = {
                "user_corrected_department": new_department,
                "correction_reason": reason,
                "corrected_at": datetime.now(timezone.utc).isoformat(),
            }

            result = self.supabase.client.table("studio_classifications") \
                .update(update_data) \
                .eq("id", classification_id) \
                .eq("user_id", user_id) \
                .execute()

            if not result.data:
                raise ClassificationUpdateError(f"Failed to update classification {classification_id}")

            # Log feedback for model improvement
            await self._log_correction_feedback(
                classification_id=classification_id,
                user_id=user_id,
                previous_department=classification.department,
                new_department=new_department,
                reason=reason
            )

            logger.info(
                "Classification corrected",
                classification_id=classification_id,
                old_department=classification.department,
                new_department=new_department
            )

            return self._row_to_classification(result.data[0])

        except ClassificationNotFoundError:
            raise
        except ClassificationUpdateError:
            raise
        except Exception as e:
            logger.error("Failed to correct classification", error=str(e), classification_id=classification_id)
            raise ClassificationUpdateError(f"Failed to correct classification: {str(e)}")

    async def _log_correction_feedback(
        self,
        classification_id: str,
        user_id: str,
        previous_department: str,
        new_department: str,
        reason: Optional[str]
    ) -> None:
        """
        Log classification correction for model improvement.
        Inserts feedback into agent_feedback table for training data collection.
        """
        try:
            # Insert into agent_feedback table
            feedback_data = {
                "agent_id": "AGENT-008",  # Department Classifier Agent
                "feedback_type": "classification",
                "input_summary": f"Classification ID: {classification_id}",
                "output_summary": f"Changed from '{previous_department}' to '{new_department}'",
                "feedback_text": reason,
                "created_by": user_id,
                "metadata": {
                    "classification_id": classification_id,
                    "previous_department": previous_department,
                    "new_department": new_department,
                    "correction_type": "classification_correction"
                }
            }

            self.supabase.client.table("agent_feedback").insert(feedback_data).execute()

            logger.info(
                "classification_correction_feedback_logged",
                classification_id=classification_id,
                user_id=user_id,
                previous_department=previous_department,
                new_department=new_department,
                reason=reason,
                feedback_type="classification_correction"
            )
        except Exception as e:
            # Don't fail the correction if feedback logging fails
            logger.warning(
                "failed_to_log_correction_feedback",
                error=str(e),
                classification_id=classification_id
            )

    async def get_classification_stats(self, user_id: str) -> Dict[str, Any]:
        """
        Get statistics about user's classifications.

        Args:
            user_id: The user ID

        Returns:
            Dictionary with classification statistics
        """
        try:
            result = self.supabase.client.table("studio_classifications") \
                .select("department, confidence, user_corrected_department") \
                .eq("user_id", user_id) \
                .execute()

            if not result.data:
                return {
                    "total": 0,
                    "by_department": {},
                    "by_confidence": {"high": 0, "medium": 0, "low": 0},
                    "corrected_count": 0
                }

            by_department = {}
            by_confidence = {"high": 0, "medium": 0, "low": 0}
            corrected_count = 0

            for row in result.data:
                # Count by department
                dept = row.get("department", "unknown")
                by_department[dept] = by_department.get(dept, 0) + 1

                # Count by confidence level
                confidence = float(row.get("confidence", 0))
                if confidence >= 0.8:
                    by_confidence["high"] += 1
                elif confidence >= 0.5:
                    by_confidence["medium"] += 1
                else:
                    by_confidence["low"] += 1

                # Count corrections
                if row.get("user_corrected_department"):
                    corrected_count += 1

            return {
                "total": len(result.data),
                "by_department": by_department,
                "by_confidence": by_confidence,
                "corrected_count": corrected_count
            }

        except Exception as e:
            logger.error("Failed to get classification stats", error=str(e), user_id=user_id)
            raise


# ============================================================================
# Service Instance
# ============================================================================

_classification_service: Optional[ClassificationService] = None


def get_classification_service() -> ClassificationService:
    """Get or create the classification service singleton."""
    global _classification_service
    if _classification_service is None:
        _classification_service = ClassificationService()
    return _classification_service
